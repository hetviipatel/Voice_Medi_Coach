import 'dart:math';
import 'package:voice_medication_coach/models/user_model.dart';

class ReferralService {
  static final ReferralService _instance = ReferralService._internal();
  factory ReferralService() => _instance;
  ReferralService._internal();

  // Mock data storage - replace with actual database/API calls
  final List<ReferralToken> _tokens = [];
  final List<UserModel> _users = [];

  // Generate a new referral token
  String generateToken(String healthWorkerId) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    final random = Random();
    String token;
    
    do {
      token = String.fromCharCodes(
        Iterable.generate(6, (_) => chars.codeUnitAt(random.nextInt(chars.length))),
      );
    } while (_tokens.any((t) => t.token == token));

    final referralToken = ReferralToken(
      token: token,
      generatedBy: healthWorkerId,
      generatedAt: DateTime.now(),
      expiresAt: DateTime.now().add(const Duration(days: 30)),
    );

    _tokens.add(referralToken);
    return token;
  }

  // Validate a referral token
  bool validateToken(String token) {
    final referralToken = _tokens.firstWhere(
      (t) => t.token == token,
      orElse: () => throw Exception('Token not found'),
    );

    if (referralToken.isUsed) {
      throw Exception('Token has already been used');
    }

    if (referralToken.expiresAt != null && 
        DateTime.now().isAfter(referralToken.expiresAt!)) {
      throw Exception('Token has expired');
    }

    return true;
  }

  // Register a new user with a referral token
  UserModel registerUserWithToken({
    required String name,
    required String email,
    required String password,
    required String referralToken,
  }) {
    // Validate the token
    validateToken(referralToken);

    // Find the token and mark it as used
    final token = _tokens.firstWhere((t) => t.token == referralToken);
    final updatedToken = ReferralToken(
      token: token.token,
      generatedBy: token.generatedBy,
      generatedAt: token.generatedAt,
      expiresAt: token.expiresAt,
      isUsed: true,
      usedBy: email, // Using email as user ID for now
      usedAt: DateTime.now(),
    );

    // Update the token in the list
    final tokenIndex = _tokens.indexOf(token);
    _tokens[tokenIndex] = updatedToken;

    // Create the new user
    final newUser = UserModel(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: name,
      email: email,
      role: 'User',
      referralToken: referralToken,
      assignedHealthWorkerId: token.generatedBy,
      createdAt: DateTime.now(),
      healthData: {
        'medicationAdherence': 0,
        'lastCheckIn': null,
        'medications': [],
        'nextAppointment': null,
      },
    );

    _users.add(newUser);
    return newUser;
  }

  // Get all tokens generated by a health worker
  List<ReferralToken> getTokensByHealthWorker(String healthWorkerId) {
    return _tokens.where((token) => token.generatedBy == healthWorkerId).toList();
  }

  // Get all users assigned to a health worker
  List<UserModel> getUsersByHealthWorker(String healthWorkerId) {
    return _users.where((user) => user.assignedHealthWorkerId == healthWorkerId).toList();
  }

  // Get user hierarchy (tree structure)
  Map<String, dynamic> getUserHierarchy(String healthWorkerId) {
    final users = getUsersByHealthWorker(healthWorkerId);
    final tokens = getTokensByHealthWorker(healthWorkerId);
    
    return {
      'healthWorkerId': healthWorkerId,
      'totalPatients': users.length,
      'activeTokens': tokens.where((t) => !t.isUsed).length,
      'usedTokens': tokens.where((t) => t.isUsed).length,
      'patients': users.map((user) => {
        'id': user.id,
        'name': user.name,
        'email': user.email,
        'adherence': user.healthData?['medicationAdherence'] ?? 0,
        'lastCheckIn': user.healthData?['lastCheckIn'],
        'medications': user.healthData?['medications'] ?? [],
        'nextAppointment': user.healthData?['nextAppointment'],
        'referralToken': user.referralToken,
        'registeredAt': user.createdAt.toIso8601String(),
      }).toList(),
      'tokens': tokens.map((token) => {
        'token': token.token,
        'generatedAt': token.generatedAt.toIso8601String(),
        'isUsed': token.isUsed,
        'usedBy': token.usedBy,
        'usedAt': token.usedAt?.toIso8601String(),
        'expiresAt': token.expiresAt?.toIso8601String(),
      }).toList(),
    };
  }

  // Update user health data
  void updateUserHealthData(String userId, Map<String, dynamic> healthData) {
    final userIndex = _users.indexWhere((user) => user.id == userId);
    if (userIndex != -1) {
      final user = _users[userIndex];
      final updatedUser = user.copyWith(
        healthData: {...user.healthData ?? {}, ...healthData},
      );
      _users[userIndex] = updatedUser;
    }
  }

  // Get user by ID
  UserModel? getUserById(String userId) {
    try {
      return _users.firstWhere((user) => user.id == userId);
    } catch (e) {
      return null;
    }
  }

  // Get user by email
  UserModel? getUserByEmail(String email) {
    try {
      return _users.firstWhere((user) => user.email == email);
    } catch (e) {
      return null;
    }
  }

  // Get all users (for admin)
  List<UserModel> getAllUsers() {
    return List.from(_users);
  }

  // Get all tokens (for admin)
  List<ReferralToken> getAllTokens() {
    return List.from(_tokens);
  }

  // Delete a token
  bool deleteToken(String token) {
    final tokenIndex = _tokens.indexWhere((t) => t.token == token);
    if (tokenIndex != -1) {
      _tokens.removeAt(tokenIndex);
      return true;
    }
    return false;
  }

  // Delete a user
  bool deleteUser(String userId) {
    final userIndex = _users.indexWhere((user) => user.id == userId);
    if (userIndex != -1) {
      _users.removeAt(userIndex);
      return true;
    }
    return false;
  }

  // Get statistics for admin dashboard
  Map<String, dynamic> getAdminStatistics() {
    final totalUsers = _users.length;
    final healthWorkers = _users.where((user) => user.role == 'Health Worker').length;
    final activeTokens = _tokens.where((token) => !token.isUsed).length;
    final usedTokens = _tokens.where((token) => token.isUsed).length;

    return {
      'totalUsers': totalUsers,
      'healthWorkers': healthWorkers,
      'activeTokens': activeTokens,
      'usedTokens': usedTokens,
      'totalTokens': _tokens.length,
      'userRegistrationRate': _calculateRegistrationRate(),
      'tokenUsageRate': usedTokens / _tokens.length,
    };
  }

  double _calculateRegistrationRate() {
    if (_users.isEmpty) return 0.0;
    
    final now = DateTime.now();
    final lastWeek = now.subtract(const Duration(days: 7));
    final recentUsers = _users.where((user) => user.createdAt.isAfter(lastWeek)).length;
    
    return recentUsers / 7.0; // Average registrations per day
  }
} 